\Chapter{Az adatbázismotor felépítése és működése}

\section{Java implementáció}

Azért a Java programozási nyelvre esett a választás, mert platformfüggetlen megoldást biztosít, illetve ezt a nyelvet már több éve tanulom, ebben van a legmagabiztosabb tudásom.

A térkép adatainak tényleges tárolásához több lehetőség is adott volt.
\begin{itemize}
\item Kidolgozható egy olyan, saját fájlformátum, amely kifejezetten térképadatok hatékony tárolására van specializálva.
\item A térképadatok kezelésének egy lehetséges módja, hogy azokat egy, már létező adatbázis modelljére képezzük le. Ezzel az adott adatbázismotort, mint kész komponenst lehet alkalmazni.
\item Az adatok strukturált tárolását XML és JSON formátumok segítségével elegánsan meg lehet oldani.
\end{itemize}

A saját fájlformátum kidolgozására, és így a tárolás alacsony szintű megvalósítására azért nem került sor, mert egyelőre annak a belátása a cél, hogy a térképadatbázis funkcióira a gyakorlatban valóban szükség van. A hatékonyság itt tehát még elsősorban a fejlesztők munkáját illetően jelenik meg, nem pedig a futási időkben és a tárigényben.

Egy létező adatbázismotornak a használata az alkalmazásoknak egy plusz külső függőséget jelentene. Az SQLite tünhet még egy szerencsés választásnak ilyen esetben, mivel az függvénykönyvtárként használható. A kialakított objektum-orientált adatbázis modell relációs modellre való leképzése természetesen megoldható lett volna, viszont a fejlesztés közben mutatkozott annál hatékonyabb megoldás.

Az XML és JSON nyelvek egyaránt alkalmasak a térkép, és a rajta lévő entitások jellemzőinek tárolásához. A JSON azért bizonyult jobb választásnak, mert az adatmodellje közelebb áll a térképadatbázis modelljéhez, feldolgozása egyszerűen megoldható és tárigényben is kisebb költséget jelent.

\section{Az adatbázismotor és a driver kapcsolata}

\begin{figure}[htb]
	\begin{center}
		\includegraphics[scale=0.1]{images/database}
		\caption{A komponensek együttműködés}
		\label{fig:database}
	\end{center}
\end{figure}

Az adatbázis motor és a Driver között a kommunikáció (\textit{az adatok tárolási módjához hasonlóan szintén}) JSON alapú. Ez lehetővé teszi, hogy a Driver és az adatbázismotor más nyelven legyen implementálva. Számítógépes játékokat implementálhatnak például C, C++, C\#, Java nyelveken, és ahhoz, hogy mindegyikkel kompatibilis legyen az adatbázismotor, ahhoz rosszabb esetben arra lenne szükség, hogy a motort minden nyelven implementáljuk. Ez nagyon fejlesztést tenne szükségessé, ehelyett csak egy drivert kell implementálni ezen nyelvekhez, amely kommunikál az adatbázis motorral. A projektre nézve a későbbiekben nem csak Java nyelven írt drivert szeretnénk, hanem C++ és C\# is a tervek között van.

\subsection{Lekérdezések kiértékelése}

Az adatbázismotor Parser komponense előállítja a lekérdezés objektumot, aminek execute metódusát végrehajtja, és ennek eredménye SELECT esetén egy lista ami objektumokat tartalmaz. Ezt a listát átadjuk a JSON Serializer komponensnek, ami előállítja ebből a listából a JSON-t, amit továbbít a Drivernek, aminek a JSON Deserializer komponense foglya feldolgozni, és előállít belőle egy eredmény listát. A Driver a kliens program számára már értelmezhető formában adja vissza az eredmény listát. Ez a körfolyamat játszódik le minden lekérdezés esetén.

\begin{comment}{Ide majd be kellene hivatkozni egy külön ábrát, vagy jelölni, hogy a komponenses ábrán mi hol zajlik éppen.}
\end{comment}

\section{Lekérdezés objektumok}

Az adatbázismotorhoz a beérkező lekérdezés stringként jön át, ezt a tokenizer feldolgozza, és minden csomopontnál meghív egy metódust, ami a lekérdezés objektumot építi fel. A lekérdezés objektum felépítése után meghívódik annak execute metódus, ami végrehajta azt.

\subsection{A SELECT lekérdezés objektum}

A legnehezebb feladat az alábbihoz hasonló lekérdezés objektumként való ábrázolása volt.

\begin{sql}
SELECT mine FROM azeroth WHERE mine.x = 10 AND mine.y < 20;
\end{sql}

A WHERE feltétel megadása és kiértékelése összetett, mivel abban egy tetszőleges számú feltételből álló, zárójelezhető kifejezés kell, hogy szerepeljen.

Az ábrázoláshoz a megoldást egy bináris fa jelentette. Kiértékeléskor elegendő postorder bejárással végigiterálnunk a fa elemein, ahogy a \ref{fig:postorder}. ábrán látható.

A fa levelein találhatóak az operandusok, a csomópontjaiban pedig a bináris logikai operátorok. Egy csomópont kiértékelésekor így mindig egy logikai kifejezést kapunk.

A SELECT lekérdezés kiértékelése ennek segítségével úgy történik, hogy a feltételt megvizsgáljuk a szóbajöhető objektumokra, és amelyikre igaz a feltétel, az belekerül az eredmény listába.

\begin{figure}[htb]
	\begin{center}
		\includegraphics[scale=0.1]{images/postorder}
		\caption{WHERE feltétel kiértékelése postorder fa bejárással}
		\label{fig:postorder}
	\end{center}
\end{figure}

\subsection{Lekérdezés feldolgozás és lekérdezés kiértékelés}

Minden lekérdezéshez készültek szintaxis diagramok, amelyek segítségével leírtuk a nyelv szerkezetét, illetve a parser erre támaszkodva tud szintaxist ellenőrizni. A diagramok éleihez érve a parser meghív egy metódust, ami a lekérdezés objektum felépítő egyik metódusa. Minden lekérdezés típushoz definiáltunk egy felépítő osztályt, ami interfész a lekérdezésobjektumok felé.


\subsection{A WHERE kifejezés ábrázolása}

A WHERE lekérdezést a kiértékeléshez gráfként kell ábrázolni. Például

\begin{sql}
WHERE ((mine.x < 10 AND mine IS Mine)
  OR (mine.location.x = 10 OR mine.y = 20)) AND mine.id = 10;
\end{sql}

A fenti lekérdezés részletet kapja meg a tokenizer komponens, akkor karakterenként elkezdi feldolgozni.

A szintaxis diagrammban feltüntetett élekre definiáltam metódusokat, melyeket a tokenizer meghívhat. 

A WhereBuilder objektum metódusait hívja meg a tokenizer.

A lekérdezés String feldolgozásának menete:

A WHERE kulcsszónál létrehozza a WhereBuilder objektumot. 
A "(" karakternél mélyít az aktuális mélységen. A builder adattagként két állapotváltozót tárol, az egyik, hogy aktuálisan a fa mely szintjén járunk, a másik pedig, hogy azon a szinten bal, vagy jobb gyerek beszúrása lesz az aktuális feladat. Mivel bináris fáról van szó, így egy csomópontnak csak két gyereke lehet, vagy egy sem, ilyenkor levélről beszélünk. Azt érdemes látni ezen a fa ábrázoláson, hogy levelek nem csak a legmélyebb szinten lehetnek.

A "mine.x" esetén a builder létrehoz egy Operand objektumot. Két Operand objektum, és egy Operator(AND, OR) objektumból a builder létrehoz egy WhereLeaf objektumot, ez a fa egyik levele lesz. Az aktuális állapotváltozókat figyelembe véve, a mélységi szintet és azt, hogy jobb vagy bal gyerek lesz ez a levél beállítja a builder. Következő metódus meghívásakor az "AND" logikai operátor adódik hozzá a fához. A builder neki is beállít egy mélységi és egy gyerek értéket. A ")" karakter észlelése után a buildernek egy olyan metódusa hívódik meg, amely az aktuális mélységi állapotváltozó értékét csökkenti eggyel.

Az említett példán szeretném bemutatni, hogy a fenti algoritmus miként működik. Ennek a lépésnek az alapja, hogy egy listába rakja a létrehozott operátorokat és operandusokat a builder lekérdezésobjektum gyártó.

- "WHERE":Ezen kulcsszó hatására létrejön a WhereBuilder objektum, a mélységi állapotváltozó értékét 1-re állítja, az aktuális gyerek értéket pedig Left(bal) értékre.
- "(": A mélységi állapotváltozó értékét kettőre növeli.
- "(": A mélységi állapotváltozó értékét háromra növeli.
- "mine.x < 10": A builder létrehoz egy WhereLeaf (levelet a fába)objektumot hozzáadva a listához, ennek a mélységi állapotváltozóját négyre állítva (levelek esetén nem az aktuális mélységi értéket, hanem azt eggyel megnövelve kell beállítani). A levél aktuális gyerek értékét Leftre állítja, és a builder a saját állapotváltozóját Rightra állítja ezen a szinten(ezt egy Map objektummal valósítom meg, ahol a kulcs az, hogy hanyadik szint a fában, az érték pedig a gyerek oldala). Tehát a builderben a négyes szinthez Right érték lett beállítva.
- "AND": A builder létrehoz egy Operator objektumot, mélységi állapot 3, gyerek Leftre állítva, majd hozzáadja a listához.

Ez így folytatódik egészen addig, amíg nem ér a String végére. A feltöltött eredménylista tartalma:

\begin{verbatim}
Mélység: 4 gyerek oldal:(false-bal, true- jobb)false mine.x < 10
Mélység: 3 gyerek oldal:(false-bal, true- jobb)false  AND
Mélység: 4 gyerek oldal:(false-bal, true- jobb)true mine IS Mine 
Mélység: 2 gyerek oldal:(false-bal, true- jobb)false  OR
Mélység: 4 gyerek oldal:(false-bal, true- jobb)false mine.location.x 
Mélység: 3 gyerek oldal:(false-bal, true- jobb)true  OR
Mélység: 4 gyerek oldal:(false-bal, true- jobb)true mine.y = 20 
Mélység: 1 gyerek oldal:(false-bal, true- jobb)false  AND
Mélység: 2 gyerek oldal:(false-bal, true- jobb)true mine.id = 10 
\end{verbatim}

Ha ezzel a lépéssel végeztünk, akkor a builder objektum ezt a listát rendezi a mélység és a gyerek oldal attribútumok szerint.
A rendezés eredménye:

\begin{verbatim}
Mélység: 1 gyerek oldal:(false-bal, true- jobb)false AND
Mélység: 2 gyerek oldal:(false-bal, true- jobb)false OR
Mélység: 2 gyerek oldal:(false-bal, true- jobb)true mine.id = 10
Mélység: 3 gyerek oldal:(false-bal, true- jobb)false AND
Mélység: 3 gyerek oldal:(false-bal, true- jobb)true OR
Mélység: 4 gyerek oldal:(false-bal, true- jobb)false mine.x < 10
Mélység: 4 gyerek oldal:(false-bal, true- jobb)true mine IS Mine
Mélység: 4 gyerek oldal:(false-bal, true- jobb)false mine.location.x
Mélység: 4 gyerek oldal:(false-bal, true- jobb)true mine.y = 20
\end{verbatim}

\begin{figure}[htb]
	\begin{center}
		\includegraphics[scale=0.1]{images/WhereBuild}
		\caption{A lekérdezésből felépített bináris fa}
		\label{fig:wherePostorderBuilder}
	\end{center}
\end{figure}

\textit{Miért jó ez a sorrend?}
Azért, mert itt már beszúrási sorrendben vannak, innentől kezdve felépíthető a fa.

A végső felépítés előtt még szükség van egy veremre, ami a lista tartalmát ugyan abban a sorrendben tárolja.

A fa felépítése a következő képen történik:

Lista tartalma: AND, OR, mine.id = 10, AND, OR, mine.x < 10, mine IS Mine, mine.location.x, mine.y = 20

A verem tartalma: AND, OR, mine.id = 10, AND, OR, mine.x < 10, mine IS Mine, mine.location.x, mine.y = 20

A két kollekció tartalma tehát megegyezik. Az algoritmust egy for ciklusban valósítunk meg, ez a ciklus pedig a lista elemein iterál végig, és minden elemnek beállítja a gyerekeit úgy, hogy a verem tetejéről levesz két elemet.
A levelekhez értelem szerűen nem lehet gyereket rendelni.

Az eredmény a lenti képen látható.

Innentől kezdve rendelkezésünkre áll egy olyan bináris fagráf, amelyet postorder bejárással végrehajtva a lekérdezés ki fog értékelődni.

\section{DELETE lekérdezés felépítése}

A következő lekérdezés érkezik az adatbázismotorhoz:
\begin{sql}
DELETE mine FROM azeroth WHERE mine.x > 10;
\end{sql}

Nem csak a lekérdezésekhez készült Builder osztály, hanem a WHERE feltétel leíróhoz is, erre azért volt szükség, mert az a részfeladat nagyon komplex, illetve több lekérdezésben is szerepet kap. A WhereBuilder-t a lekérdezés felépítő osztályok magukba foglalják, definiálnak pontosan ugyan olyan metódusokat mint ami a WhereBuildernek van, és azokban csak tovább hívják annak azonos metódusait.

Hasonlóan történt az implementáció a DeleteBuilder osztálynál is. 

\begin{figure}[htb]
	\begin{center}
		\includegraphics[scale=0.4]{images/delete}
		\caption{A DELETE lekérdezés szintaxis diagramja}
		\label{fig:deleteSytnax}
	\end{center}
\end{figure}

A szintaxis diagram alapján ezek a metódusok hívódnak meg a DeleteBuilder objektumnak:

DeleteBuilder builder = new Builder(); \\
builder.createDelete("mine"); \\ 
builder.setFrom("azeroth"); \\
builder.addOperandPiece("mine.x"); \\
builder.addOperator(">"); \\
builder.addOperandPiece("10"); \\
builder.build(); \\

Minden builder osztályban definiáltunk egy build metódust, ami egy IQueryObject példányt ad vissza. Minden lekérdezés objektum implementálja az IQueryObject interfészt, ami egy execute() metódust tartalmaz.



\section{ALTER lekérdezés felépítése}

A következő lekérdezés érkezik az adatbázismotorhoz:
\begin{sql}
ALTER CLASS Rectangle DELETEATTRIBUTE x;
\end{sql}


\begin{figure}[htb]
	\begin{center}
		\includegraphics[scale=0.4]{images/alter}
		\caption{Az ALTER lekérdezés szintaxis diagramja}
		\label{fig:alterSytnax}
	\end{center}
\end{figure}

A builder objektum metódusainak használata a fenti lekérdezés esetében:

AlterBuilder builder = new AlterBuilder(); \\
builder.createAlter("Rectangle"); \\
builder.setAlterType("DELETEATTRIBUTE"); \\
builder.setStringAttribute("x"); \\
builder.build(); \\

Az Alter lekérdezés 4 típust definiál:

\begin{itemize}
\item Osztálynév módosítás
\item Attribútum törlés
\item Attribútum definiálás
\item Attribútum átnevezése
\end{itemize}

Ezek közül az attribútum létrehozáshoz és átnevezéshez egy plusz attribútumra van szükség, amelyet a builder.setOptionalValue(attribute-name or attribute-Type)
metódussal állíthatjuk be.

\section{CREATE lekérdezés felépítése}

A CREATE lekérdezéssel adatbázist, térképet és osztály definíciót lehet létrehozni. Az adatbázisnak és a térképnek a definiálása a legkönnyebb lekérdezések egyike, és az osztály definiálása ugyan azon lépésekből áll, csak egy párat definiál pluszba hozzájuk.

\begin{figure}[htb]
	\begin{center}
		\includegraphics[scale=0.4]{images/create}
		\caption{A CREATE lekérdezés szintaxis diagramja adatbázis és térkép létrehozásra szűkítve}
		\label{fig:createSytnax}
	\end{center}
\end{figure}

\begin{figure}[htb]
	\begin{center}
		\includegraphics[scale=0.4]{images/createclass}
		\caption{A CREATE lekérdezés szintaxis diagramja osztálydefiníció definiálásához}
		\label{fig:createClassSytnax}
	\end{center}
\end{figure}



A következő lekérdezés érkezik az adatbázismotorhoz:
\begin{sql}
CREATE CLASS Harcos(
Number kor,
Number attack DEFAULT 10,
String nev);
\end{sql}

CreateBuilder builder = new CreateBuilder();
builder.setCreateType("CLASS"); \\
builder.setTheCommonValue("Harcos"); \\
builder.addAttributeParam("Number"); \\
builder.addAttributeParam("kor"); \\
builder.insertAttribute(); \\
builder.addAttributeParam("Number"); \\
builder.addAttributeParam("attack"); \\
builder.addAttributeParam("10"); \\
builder.insertAttribute(); \\
builder.addAttributeParam("String"); \\
builder.addAttributeParam("nev"); \\
builder.build(); \\

Vessző karaktereknél és a ")" karakternél hívódik meg az insertAttribute metódus, ami beszúrja az attribútumot.


\section{UPDATE lekérdezés felépítése}

A következő lekérdezés érkezik az adatbázismotorhoz:
\begin{sql}
UPDATE azeroth SET x=30,y=40 WHERE mine.id = 10;
\end{sql}

\begin{figure}[htb]
	\begin{center}
		\includegraphics[scale=0.4]{images/update}
		\caption{Az UPDATE lekérdezés szintaxis diagramja}
		\label{fig:updateSytnax}
	\end{center}
\end{figure}



\section{Számítások optimalizálása}

Az adatbázismotor feladata levenni a terhet a felhasználó válláról, 
optimalizált algoritmusokkal támogatni a lekérdezéseket. Térképfelosztás, pályaelem összevonás, ezek mind olyan feladatok,
amelyek a térképműveletek gyorsabb végrehajtását idézik elő.
Mivel a dolgozatnak egyenlőre nem célja, hogy a piacon versenyképes szoftver legyen, ezért az optimalizálás nem került bele a dolgozatba.


